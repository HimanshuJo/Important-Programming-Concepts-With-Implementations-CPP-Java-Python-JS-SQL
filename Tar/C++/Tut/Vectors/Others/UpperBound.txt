upper_bound():

	is a standard library function in C++ defined in the header.

	It returns an iterator pointing to the first element in the range [first, last) 
	that is greater than value, or last if no such element is found. 

	The elements in the range shall already be sorted or at least partitioned with respect to val.

-------

Syntax 1:

	ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T& val);

Syntax 2:

	ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T& val, Compare comp);

-------

first, last: 

	The range used is [first, last), which contains all the elements between first and last, 
	including the element pointed by first but not the element pointed by last.

-------

val: 

	Value of the upper bound to search for in the range.

comp: 

	Binary function that accepts two arguments (the first of the type pointed by ForwardIterator, and the second, always val), 
	and returns a value convertible to bool. 

	The function shall not modify any of its arguments. 

	This can either be a function pointer or a function object.

Return type: 

	An iterator to the upper bound of val in the range. 

	If all the element in the range compare less than val, the function returns last.

-------

Examples :

Input : 10 20 30 30 40 50
Output : upper_bound for element 30 is at index 4

Input : 10 20 30 40 50
Output : upper_bound for element 45 is at index 4

Input : 10 20 30 40 50
Output : upper_bound for element 60 is at index 5

-------

// CPP program to illustrate using
// std :: upper_bound with vectors
#include <bits/stdc++.h>

int main()
{
	std::vector<int> v{ 10, 20, 30, 40, 50 };

	std::cout << "Vector contains :";
	for (int i = 0; i < v.size(); i++)
		std::cout << " " << v[i];
	std::cout << "\n";

	std::vector<int>::iterator upper1, upper2;

	// std :: upper_bound
	upper1 = std::upper_bound(v.begin(), v.end(), 35);
	upper2 = std::upper_bound(v.begin(), v.end(), 45);

	std::cout << "\nupper_bound for element 35 is at position : "
			<< (upper1 - v.begin());
	std::cout << "\nupper_bound for element 45 is at position : "
			<< (upper2 - v.begin());

	return 0;
}

Output:

Vector contains : 10 20 30 40 50
upper_bound for element 35 is at position : 3
upper_bound for element 45 is at position : 4

-------

// CPP program to illustrate using
// std :: upper_bound with 'arrays'
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int arr[] = { 10, 20, 30, 40, 50 };

	cout << "Array contains :";
	for (int i = 0; i < 5; i++)
		cout << " " << arr[i];
	cout << "\n";

	// using upper_bound
	int upper1 = upper_bound(arr, arr+5, 35) - arr;
	int upper2 = upper_bound(arr, arr+5, 45) - arr;

	cout << "\nupper_bound for element 35 is at position : "
			<< (upper1);
	cout << "\nupper_bound for element 45 is at position : "
			<< (upper2);

	return 0;
}

Output:

Array contains : 10 20 30 40 50
upper_bound for element 35 is at position : 3
upper_bound for element 45 is at position : 4

-------

Time Complexity: 

	The number of comparisons performed is logarithmic in the distance between first and last. i.e, 
	(at most log2(last â€“ first) + O(1) comparisons).