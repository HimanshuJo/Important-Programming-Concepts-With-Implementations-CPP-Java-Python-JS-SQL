
LeetCode wants to give one of its best employees the option to travel among N cities
	to collect algorithm problems.

	But all work and no play makes Jack a dull boy, you could take vacations in some
	particular cities and weeks.

	Your job is to schedule the traveling to maximize the number of vacation days
		you can take, but there are certain rules and restrictions you need to follow

	-------

	Rules and restriction:

		1. You can travel among N cities, represented by indexes from 0 to N - 1
			you are initially in the city index 0 on Monday

		2. The cities are connected by flights.
			
			The flights are represented as a N*N matrix (not necessary symmetrical)
			called flights representing the airline status from the city i to the city j

			If there is no flight from the city i to the city j

			flights[i][j] = 0

			Otherwise flights[i][j] = 1

			Also, flights[i][i] = 0 for all i

		3. You totally have K weeks (each week has 7 days) to travel.

			You can take flights at most once per day and can only take flights
				on each week's Monday morning

			Since flight time is so short, we don't consider the impact of flight time

		4. For each city, you can have restricted vacation days in different weeks, given an
			N * K matrix called days representing this relationship.

			For the value of days[i][j], it represents the maximum days you could take vacation
				in the city i in the week j

	You are given the flights matrix and days matrix and you need to output the maximum vacation
		days you could take during K weeks

	Example:

		Input: # rows -> city i, cols -> city j

				flights = [[0, 1, 1], [1, 0, 1], [1, 1, 0]]

			    -------

			     0 1 1
			     1 0 1
			     1 1 0

			   # rows -> cities, cols -> no. vac. days

				days = [[1, 3, 1], [6, 0, 3], [3, 3, 3]]

				-------

				1 3 6
				6 0 3
				3 3 3

		Output: 12

-------

Intuition:

	Basic DP problem

	Classic graph + DP problem

	-------

	basic idea is to try all the possible ways

	-------

	In this problem we have to utilize a 2D DP array
		city and current week

	Top down DP is more intuitive
		We are moving from one city to the another

		so it is easier to calculate the possible moves from the current city to the next city

	-------

	If we want to use the Bottom up DP
		that means we need to go backwards

		we have to check in how may ways we can get to the current city

-------

class Solution:
	def maxVacationDays(self, flights: List[List[int]], days: List[List[int]]) -> int:
			
		def dp(city, week):
			if (city, week) in memo:
				return memo[(city, week)]

			if week > weeks - 1:
				return 0

			ans = -sys.maxsize

			# How to get the max value of the ans
			# It depends on how many values we currently have
			# First option is to always stay at the current city

			# If we decide to stay at the current city, and
			# with the current week 
			# we can get some no. of vacation days (for this city, for this week)
			# After this, the next one will be the city starting from the same city
			# Because we are staying at city, so on the next week we will also start at the
			# same city, and the week will be week  + 1

			# STAYING AT THE SAME CITY
			ans = max(ans, days[city][week] + dp(city, week + 1))

			# GOING TO OTHER CITY
			for neighbor in graph[city]:
				ans = max(ans, days[neighbor][week] + dp(neighbor, week + 1))	

			memo[(city, week)] = ans

			return ans

		# we have to maintain a graph here
		# so that every time we don't have to loop through all the cities

		graph = defaultdict(list)

		n = len(flights) # city is same as the dimensions of the flights

		weeks = len(days[0])  # total weeks we have
		
		for i in range(n):
			for j in range(n):
				if flights[i][j] == 1:
					# add an edge
				  	# so that next time when I try to check from the current city, how many
				  	# neighbors I can go, we can loop through the graph here
					graph[i].append(j)

		# in the recursive solution, we always need memoization
		memo = {}

		return dp(0, 0)  # because initially we start from the city 0